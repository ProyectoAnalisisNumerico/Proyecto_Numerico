---
title: "Modelo Lasso"
output: word_document
---

# Carga de paquetes

```{r}
#install.packages("faraway")
#install.packages("tidyverse")
#install.packages("skimr")
#install.packages("DataExplorer")
#install.packages("scales")
#install.packages("corrr")
###### Para el modelamiento #####
#install.packages("glmnet")
#install.packages("pls")
#install.packages("MLmetrics")
#install.packages("writexl")
```

# Carga de librerias
```{r}
library(faraway)
library(tidyverse)
library(skimr)
library(DataExplorer)
library(scales)
library(corrr)
library(glmnet)
library(pls)
library(MLmetrics)
library(dplyr)
library(stringr)
```

```{r}
library(readxl)
datosL <- read_excel("Resultados_de_Análisis_de_Laboratorio_Suelos_en_Colombia_20251027.xlsx")
head(datosL)
```
# Limpieza de variables
```{r}
# Eliminar las columnas innecesarias dejando aquellas relacionadas con los aspectos fisicos y quimicos
datosL1 <- datosL[, !names(datosL) %in% c(
  "Secuencial",
  "Fecha de Análisis",
  "Topografia",
  "Drenaje",
  "Riego",
  "Departamento",
  "Municipio",
  "Cultivo",
  "Estado",
  "Tiempo de establecimiento",
  "Fertilizantes aplicados",
  "Hierro disponible doble acido",
  "Cobre disponible doble acido",
  "Manganeso disponible doble acido",
  "Zinc disponible doble acido"
)]

# Verificar que esten las variables que se utilizaran para el modelo Lasso
head(datosL1)
```
En esta etapa se realizó un proceso de depuración de las variables incluidas en la base de datos con el objetivo de eliminar aquellas que no aportan información relevante al estudio y evitar problemas de colinealidad en el modelo.

En primer lugar, se excluyeron las variables administrativas y descriptivas como Secuencial, Fecha de análisis, Departamento, Municipio, Cultivo, Estado, Tiempo de establecimiento y Fertilizantes aplicados, ya que corresponden a información contextual o identificadores sin relación directa con las propiedades físico-químicas del suelo.

Posteriormente, se eliminaron las variables medidas por el método de Doble Ácido (Hierro disponible doble ácido, Cobre disponible doble ácido, Manganeso disponible doble ácido y Zinc disponible doble ácido), dado que representan duplicados de los mismos micronutrientes ya evaluados mediante el método Olsen, que es el estándar más aceptado para estimar la fracción disponible de estos elementos. Mantener ambas mediciones podría introducir redundancia y multicolinealidad en el modelo Lasso.

Finalmente, se conservaron las variables físicas (Topografía, Drenaje y Riego) y las químicas (pH, Fósforo, Calcio, Magnesio, Potasio, Sodio, Conductividad eléctrica, entre otras), las cuales inciden directamente sobre la materia orgánica del suelo, variable dependiente del estudio. Estas variables permiten capturar la interacción entre las condiciones edáficas y la disponibilidad de nutrientes, factores determinantes en la fertilidad de los suelos agrícolas de Colombia.


En esta etapa se realizó la transformación de las variables categóricas Topografía, Drenaje y Riego a valores numéricos con el fin de incorporarlas en los modelos Ridge y Lasso.
Se asignaron valores ordinales basados en criterios agronómicos, donde valores mayores representan condiciones más favorables para la fertilidad del suelo.
Además, las categorías “No indica” se trataron como valores faltantes (NA), ya que corresponden a información no reportada y no deben confundirse con valores válidos como “No Tiene”.
Esta codificación garantiza coherencia en la interpretación de las variables y permite su uso adecuado en los modelos de regresión penalizada.

```{r}
datosL2 <- datosL1
limpiar_columna <- function(x) {
  x <- as.character(x)
  x <- str_trim(x)                # eliminar espacios en blanco
  x <- toupper(x)                 # uniformar texto
  
  # Reemplazar ND, NA, vacíos → NA real
  x[x %in% c("ND", "NA", "", "N/D", "NULO", "<0.09")] <- NA
  
  
  # Convertir a numérico de forma segura (sin warnings)
  suppressWarnings(as.numeric(x))
}

# Aplicar a las columnas numéricas
cols_numericas <- c(
  "pH agua:suelo",
  "Materia organica",
  "Magnesio intercambiable",
  "Potasio intercambiable",
  "Sodio intercambiable",
  "capacidad de intercambio cationico",
  "Conductividad electrica",
  "Hierro disponible olsen",
  "Manganeso disponible Olsen",
  "Zinc disponible Olsen",
  "Boro disponible",
  "Fósforo Bray II",
  "Azufre Fosfato monocalcico",
  "Acidez Intercambiable",
  "Aluminio intercambiable",
  "Calcio intercambiable",
  "Cobre disponible"
)

datosL2[cols_numericas] <- lapply(datosL2[cols_numericas], limpiar_columna)
head(datosL2)

```

# Preparación de los datos para el modelo

## Separar variables dependiente e independientes
```{r}
# Separar variable dependiente (Y)
yL <- datosL2$`Materia organica`

# Seleccionar solo las predictoras numéricas (excluyendo Y)
XL <- datosL2 %>%
  select(-`Materia organica`) %>%
  select(where(is.numeric))
```

## Escalar (estandarizar) las variables predictoras

```{r}
# Aplicar logaritmo natural
XL <- as.data.frame(lapply(XL, log1p))

# Escalar (centrar y normalizar)
X_scaledL <- as.data.frame(scale(XL))

# Verificar medias y desviaciones
apply(X_scaledL, 2, mean, na.rm = TRUE)[1:5]   # deberían ser ~0
apply(X_scaledL, 2, sd, na.rm = TRUE)[1:5]     # deberían ser ~1
```
## Eliminar Outliers Extremos

```{r}
#par(mfrow = c(1, 1))  # ajusta según la cantidad de variables
#for (col in names(X_scaledL)) {
#  boxplot(X_scaledL[[col]], 
#          main = col, 
#          col = "lightblue", 
#          border = "darkblue",
#          outline = TRUE,
#          cex.axis = 0.6, cex.main = 0.8)
#}

vars_sesgadas <- c(
  "Azufre.Fosfato.monocalcico",
  "Conductividad.electrica",
  "Potasio.intercambiable",
  "Sodio.intercambiable",
  "Zinc.disponible.Olsen",
  "Boro.disponible")

winsorizar <- function(x, lower = 0.01, upper = 0.99) {
  q <- quantile(x, probs = c(lower, upper), na.rm = TRUE)
  x[x < q[1]] <- q[1]
  x[x > q[2]] <- q[2]
  return(x)
}

X_scaledL_wins <- X_scaledL
X_scaledL_wins[vars_sesgadas] <- lapply(X_scaledL[vars_sesgadas], winsorizar)
#X_scaledL_wins <- as.data.frame(lapply(X_scaledL, winsorizar))

comparacion_rangos <- data.frame(
  Variable = names(X_scaledL),
  Min_Antes = sapply(X_scaledL, min, na.rm = TRUE),
  Max_Antes = sapply(X_scaledL, max, na.rm = TRUE),
  Min_Despues = sapply(X_scaledL_wins, min, na.rm = TRUE),
  Max_Despues = sapply(X_scaledL_wins, max, na.rm = TRUE)
)
comparacion_rangos


par(mfrow = c(1, 2))  # ajusta según la cantidad de variables
for (col in names(X_scaledL_wins)) {
  boxplot(X_scaledL_wins[[col]], 
          main = col, 
          col = "lightblue", 
          border = "darkblue",
          outline = TRUE,
          cex.axis = 0.6, cex.main = 0.8)
}
par(mfrow = c(1, 1))
```




## Combinar datos en un dataset final

```{r}
datos_finalL <- cbind(X_scaledL_wins, Materia_Organica = yL)
datos_finalL <- na.omit(datos_finalL)
head(datos_finalL)

```

#  MODELO LASSO (α = 1)

```{r}
set.seed(1235)
id_train <- sample(1:nrow(datos_finalL), size = 0.7 * nrow(datos_finalL), replace = F)

datos_train <- datos_finalL[id_train, ]
datos_test  <- datos_finalL[-id_train, ]

dim(datos_train); dim(datos_test)
```

```{r}
x_train <- model.matrix(Materia_Organica ~ ., data = datos_train)[, -1] # El -1 quita la primera columna (intercepto)
y_pre_train <- datos_train$Materia_Organica

x_test <- model.matrix(Materia_Organica ~ ., data = datos_test)[, -1]
y_pre_test <- datos_test$Materia_Organica

y_train <- log1p(y_pre_train) 
y_test <- log1p(y_pre_test)
```

```{r}
modelo <- glmnet(
  x = x_train,
  y = y_train,
  alpha = 1,
  nlambda = 100, 
  standardize = TRUE 
)
```

```{r}
# Error medio de validación cruzada
regularizacion <- modelo$beta %>%
as.matrix() %>%
t() %>%
as_tibble() %>%
mutate(lambda = modelo$lambda)

regularizacion <- regularizacion %>%
pivot_longer(
cols = !lambda,
names_to = "predictor",
values_to = "coeficientes"
)

regularizacion %>%
ggplot(aes(x = lambda, y = coeficientes, color = predictor)) +
geom_line() +
scale_x_log10(
breaks = trans_breaks("log10", function(x) 10^x),
labels = trans_format("log10", math_format(10^.x))
) +
labs(title = "Coeficientes en función de la regularización (LASSO)",
x = "λ (penalización logarítmica)",
y = "Valor del coeficiente") +
theme_bw() +
theme(legend.position = "none")
```
# Evolución del error en función de lambda

```{r}
set.seed(123)
cv_error <- cv.glmnet(
x = x_train,
y = y_train,
alpha = 1, # 1 = LASSO
nfolds = 10, # Validación cruzada de 10 pliegues
type.measure = "mse"
)

plot(cv_error)

```

```{r}
paste("Mejor Lambda encontrado:", cv_error$lambda.min)
```
```{r}
paste("Lambda óptimo + 1 desviación estándar:", cv_error$lambda.1se)
```
```{r}
modelo <- glmnet(
x = x_train,
y = y_train,
alpha = 1,
lambda = cv_error$lambda.1se,
standardize = TRUE
)
```

```{r}
df_coeficientes <- coef(modelo) %>%
as.matrix() %>%
as_tibble(rownames = "predictor") %>%
rename(coeficiente = s0)

df_coeficientes %>%
filter(predictor != "(Intercept)") %>%
ggplot(aes(x = reorder(predictor, coeficiente), y = coeficiente, fill = coeficiente > 0)) +
geom_col(show.legend = FALSE) +
coord_flip() +
labs(title = "Coeficientes del modelo LASSO",
x = "Variable", y = "Valor del coeficiente") +
theme_bw() +
theme(axis.text.y = element_text(size = 7))

library(xlsx)
write.xlsx(df_coeficientes, "Coeficientes_lasso.xlsx")

```

```{r}
predicciones_train <- predict(modelo, newx = x_train)
```

```{r}
training_lasso <- mean((predicciones_train - y_train)^2)
paste("Error (MSE) de entrenamiento:", training_lasso)
```

```{r}
predicciones_test <- predict(modelo, newx = x_test)
```

```{r}
test_mse_lasso <- mean((predicciones_test - y_test)^2)
paste("Error (MSE) de test:", test_mse_lasso)
```

```{r}
MAPE <- function(pred, real) {
mean(abs((real - pred) / real), na.rm = TRUE)
}

MAPE_val <- round(MAPE(predicciones_test, y_test) * 100, 2)
paste("MAPE:", MAPE_val, "%")
```

# Comparación predicciones con los valores reales de Materia orgánica.

```{r}
# Volver a la escala original: exp(valor) - 1
pred_test_real <- exp(predicciones_test) - 1
real_test <- exp(y_test) - 1

head(pred_test_real)
head(real_test)
```


```{r}
comparacion <- data.frame(
  Real = round(real_test[1:15], 3),
  Predicho = round(pred_test_real[1:15], 3)
)

comparacion
```




El modelo LASSO logró identificar las variables físico-químicas más relevantes para explicar la materia orgánica del suelo y generó predicciones consistentes en el rango donde se concentra la mayoría de los datos. Sin embargo, el modelo tiende a sobreestimar los valores bajos y a subestimar los valores altos, lo que indica que no captura adecuadamente los comportamientos extremos de la variable dependiente. Esto puede deberse tanto a la transformación logarítmica aplicada como a la baja representatividad de valores altos en la base de datos. En general, el modelo es útil para estimaciones preliminares.
